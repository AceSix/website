import React from 'react'
import RGBColorPicker from '/resources/components/RGBColorPicker'

export const documentProps = { title: 'Lab 2' }

# Lab 2: Pencils

- [Github Classroom assignment](todo)
- [Anonymous feedback form](https://forms.gle/ZYY519pzSvu8YaZK6)

## Introduction

Welcome to Lab 2!

In this lab, we'll take our first steps into computer graphics by taking a look at how digital images are represented and modified. This lab is also designed to help you get more comfortable with Qt and C++, and to prepare you for `Project 1: Brush`.

In the rest of this lab, you will:

1. Learn about how colors and digital images are represented,
2. Create pixel art by programmatically modifying an image, and
3. Implement a Photoshop-like "pencil" to draw on a canvas.

## Getting Started

:::warning
All subsequent labs and projects in CS 1230 will follow these same getting-started instructions. _We won't repeat them again!_

If you have doubts or questions at any point, be sure to check with a TA or ask on Ed.
:::

### Stencil Code

Like in lab 1, we've provided you with some [stencil code](todo) to get you started. As always, you should `git clone` this repository to your local machine and open the project in QtCreator.

Once that's done, run the application by hitting the "play" button on the bottom left of the Qt creator interface.

### Application Windows

_Unlike_ in lab 1, instead of console output, you should see an **application window** (with nothing in it) appear. This is what we will be using to visualize and interact with our images.

:::todo
Image of application window
:::

> Interested in how GUI elements like these are set up? Feel free to take a look at [ todo: these specific files ] in our stencil code!

### Command Line Arguments

For this and future assignments, we will be using **command line arguments** to toggle between different configurations.

To specify command line arguments, click into the `Projects` tab on the left sidebar, and use the text field at `Build and Run > Run > Command Line Arguments`. These will be supplied to the app at runtime.

:::todo
Screenshot of interface to set command line arguments
:::

In this lab, our application expects exactly one argument which specifies the type of canvas you wish to display: `grayscale` or `color`. If nothing is provided, the app defaults to the latter.

:::task
Set the command line argument so that the application displays a canvas in `grayscale`.
:::

Once you see [ todo ], you're ready to proceed to the next section and begin the lab proper.

<details>
  <summary>Why do we use command line arguments?</summary>

In general, it's a good idea to separate config (configuration) from code. There are many reasons to do this, but for us, it primarily serves to **reduce development latency**.

You _might_ have noticed while completing the above task that the delay between hitting "play" and the window being displayed was shorter than it was before. This is because changing command line arguments doesn't trigger a re-build of the app from C++ source code.

If our config was instead stored in the source code, any changes to that config would trigger a time-consuming build, which can be very annoying when developing or debugging.

Of course, command line arguments aren't the only way of separating config from code: there are plenty of other ways to express configuration in Qt, including `QConfig`, which you might see later in the course.

</details>

## Representing Colors

In computer graphics, **images** are usually represented as two-dimensional arrays of **pixels**, each of which contains some kind of data.

In most cases, images typically encode **color** information.

:::todo
A digital photograph or artwork
:::

However, images can _really_ be used to encode any kind of information: later in this course, you'll use [height maps](https://en.wikipedia.org/wiki/Heightmap) and [depth buffers](https://en.wikipedia.org/wiki/Z-buffering) to encode linear displacement, and even [normal maps](https://en.wikipedia.org/wiki/Normal_mapping) to encode directions!

:::todo
Samples of other types of images
:::

That said, we're primarily interested in color images, so let's explore how we can represent color in code.

### Grayscale

Each pixel in a grayscale image requires only a **_single_** real-numbered value to encode its intensity. Equivalently, we might say that a grayscale image has a **_single_ channel**.

One possible representation of a grayscale image is to use `float`s to encode each pixel's intensity. We could arbitrarily define `0` as the darkest color (black), and `1` as the lightest color (white).

:::todo
Image of grayscale colors
:::

### RGBA

Ah, but grayscale images are kinda boring. Past this lab, we'll be using [RGBA color images](https://en.wikipedia.org/wiki/RGBA_color_model) for most assignments in CS 1230.

Unlike with grayscale images, in an RGBA-colored image, every color requires **_four_** distinct values. Equivalently, we might say that an RGBA color image has **_four_ channels**.

Of these, three values give the `red`, `green`, and `blue` components, and the remaining `alpha` value gives the opacity of the color. **Typically, `int`s in the range `[0, 255]` are used for each value**&mdash;more on that in the next subsection.

As you will learn more about `alpha` in your projects, we'll omit it for this lab (assume it's always `255`, or "full opacity"). Instead, we'll look at `RGB` triplets: e.g. an `RGB` value of `(255,0,0)` represents pure red, and `(255,0,128)` adds a little blue to make a warm pink.

:::todo
Image of RGBA colors
:::

:::task
Play around with the color picker below.

<RGBColorPicker />

What do you think it means when we say that the RGBA color model is an _**additive**_ color model, as opposed to a _subtractive_ one?
:::

### A Note On Types and Memory

Earlier, we mentioned using `float`s ranging from `0` to `1` to represent grayscale color intensities. However, `float`s usually occupy 4 (or even 8) bytes, and this can quickly add up: if we used 8-byte floats, each pixel would require 32 bytes, and a `1000 x 1000` RGBA image would occupy $1000 * 1000 * 4 * 8 B = 32 \text{ MB}$ of memory!

**Instead, the vast majority of displays today use [24-bit true color](<https://en.wikipedia.org/wiki/Color_depth#True_color_(24-bit)>) (8 bits per color channel).** This allows us to represent $2^8 = 256$ values per color channel, which then gives us $256^3 \approx 17 \text{ million}$ different RGB colors. This is more than enough\* as the human eye can discriminate only around 10 million colors.

Conveniently, 8 bits is also the size of an **unsigned integer** in the range `[0, 255]`, so...

:::success
In CS 1230, the type we will be using for our color channel data is **`std::uint8_t`**, provided by the C++ standard library.
:::

<details>
  <summary>A historical tidbit: 8-bit color</summary>

A single pixel occupying 24 bits was completely unthinkable in the early days of computer graphics, when memory was much more expensive. Getting around this limitation is why methods like **[8-bit color](https://en.wikipedia.org/wiki/8-bit_color)** (3 red, 3 green, 2 blue) existed.

There were plenty of other [color depths](https://en.wikipedia.org/wiki/Color_depth), too: 1-bit, 2-bit, 4-bit, etc.

</details>

<details>
  <summary>\* Is 24 bits _really_ enough?</summary>

While it is indeed true that the human eye can discriminate only around ten million colors, those colors aren't necessarily distributed in "perception space" the same way as they are distributed in "display space" (the subset of colors that can be produced by a display).

Consequently, we can in fact perceive supposedly-smooth changes in color as [color banding](https://en.wikipedia.org/wiki/Colour_banding). Depending on the quality of your device's display, you _might_ perceive color banding in the gradient below:

<div style={{ height: 40, background: 'linear-gradient(to left, #333, #666)' }} />

</details>

### Float - Uint Conversion

Despite all of that, in some cases, it might just be easier to work with `float`s. This is especially so for image processing applications, and in later projects, you might find yourself working with `float`s for intermediate color data, too.

Wouldn't it be convenient if you had a helper function to be able to convert between `float`s and `std::uint8_t`s?

:::task

In [ todo: function location ], implement a function to convert `float` values in the range [0, 1] to `std::uint8_t`s in the range [0, 255].

**Hint:**

You might want to check out the [`round()` function](https://cplusplus.com/reference/cmath/round/) in the built-in `cmath` library, which may be `#include`-ed like so:

```cpp
#include <cmath>;
```

:::

## Your First Canvas

Now that we've completed our foray into color representation, we can move on to images. But, in order to operate on an image, we first need to create one!

### Creating 2D Arrays

In lab 1, you learned that you can use **containers** like `std::vector` or `std::array` to store linear collections of data. Though these are one-dimensional data structures, we can fairly easily view them as 2D ones if we squint a little:

:::todo
Array turning into 2D array gif
:::

This illustrates two ways of viewing 1D data-structures as 2D ones:

1. row-major order, and
2. column-major order

:::success
In CS 1230, we will store all our pixel data in **row-major order**.
:::

:::task

Create a _grayscale_ image using a 2D array.

1. In [ todo: function ], initialize a gray canvas of `10 x 10` pixels by creating a `std::vector` of `float`s in [ todo: location], then
2. Set the initial value of all its elements to `0.123`.
   - Do not use any `for` loops.
   - You may find `std::fill` or the `std::vector` constructor useful.

:::

:::task

Display what your image by passing the vector to `displayGrayCanvas()` at [ todo: location ], then build and run the application.

Remember to check that you provided the correct command line arguments.

:::

If you see a gray box, you're good. From now on, we will be using this image as our canvas, and you'll figure out how to 'draw' on it.

### Modifying 2D Arrays

[ WIP ]

By modifying data values in the array you just created, you can make the corresponding points, or pixels turn to different colors.

You can try changing a random data to 255 and observe what happen.

A white dot showed up on your canvas, right?

Your job in this section, is to work our which pixel correspond to which element in the array, and change their values. Refer to the explanation on row-major-order for hint.

:::task

Match this image by indexing and changing values of the vector you just created.

![todo](/public/labs/lab2/pixelHeart.png)

:::

### The RGBA Struct

Now, let's change the canvas to a colorful one. Instead of a `std::vector` of numbers, we want a `std::vector` of something that contains all 4 RGBA channels.

#### The CS 1230 RGBA Struct

Since we have to group several related variables together, we should create a `struct`. A simple example of how to define an RGBA struct is below:

```c++
#ifndef SIMPLE_RGBA
#define SIMPLE_RGBA

struct SimpleRGBA
{
	std::uint8_t r;
	std::uint8_t g;
	std::uint8_t b;
	std::uint8_t a;
}

#endif
```

::::task

Define an RGBA struct in your own project by copying the above code into a _new_ **header file**.

<details>
  <summary>Step by step: how to create a new file in Qt</summary>

- Right click on the Project side-bar and select `Add New`
- You should see an interface asking you to select the type of file you'd like to add. Select `C/C++ header file`.

:::todo
Screenshots
:::

- Follow the interface instructions to define the name and location of your header file.
- In the Project Management section, select `Done`.
- You should see a new header file appear in your chosen location after a few seconds.

</details>

::::
